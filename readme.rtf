{\rtf1\ansi\ansicpg1252\deff0\deflang1033\deflangfe1033{\fonttbl{\f0\fswiss\fprq2\fcharset0 Calibri;}{\f1\fmodern\fprq1\fcharset0 Consolas;}{\f2\fnil\fcharset0 Consolas;}{\f3\fnil Consolas;}}
{\colortbl ;\red0\green0\blue255;\red156\green22\blue22;\red0\green128\blue0;}
{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\nowidctlpar\sl276\slmult1\qc\lang9\b\f0\fs36 PEel\par
\b0\i\fs14 a PE editing library\b\i0\fs36\par
\b0\i\fs28 by x8esix\ul\b\i0\fs18\par
\pard\nowidctlpar\sl276\slmult1\fs28\par
Project Home:\par
\ulnone\b0\i\fs18\par
\pard\fi720{\field{\*\fldinst{HYPERLINK "http://github.com/x8esix/PEel/"}}{\fldrslt{\ul\cf1 http://github.com/x8esix/PEel/}}}\f0\fs18\par
\pard\nowidctlpar\sl276\slmult1\ul\b\i0\fs28\par
Background:\ulnone\b0\fs22\par
\par
\pard\nowidctlpar\fi720\sl276\slmult1 Lack of a decent library to manipulate and view PE and PE32+ files in both file and virtual alignment, as was needed for multiple projects I was working on, created the need for this library. At the moment, it currently provides support to manipulate most values easily and provides an interface to manipulate PE sections and alignments. Higher level functions that handle alignment automatically and allow for adjustment of sections and imports/exports will be added.\par
\pard\nowidctlpar\sl276\slmult1\ul\b\fs28\par
Notes:\ulnone\b0\fs22\par
\par
\pard\nowidctlpar\fi720\sl276\slmult1 To use, include \cf2 PEel_public.h\cf0  in your project and link to \cf2 PEel.lib\cf0 .\par
\pard\nowidctlpar\sl276\slmult1\par
\ul\b\fs28 Changelist:\ulnone\b0\fs22\par
\par
    0.1: Initial release, supports:\par
\tab Import enumerating\par
\tab Export enumerating\par
\tab Resource enumerating\par
\tab Relocating\par
\tab Checksumming\par
\tab Image/File aligned attachments\par
\tab Conversions between alignments\par
\tab Multiple helper functions for conversions and general data gathering\par
\par
\ul\b\fs28 TODO:\ulnone\b0\fs22\par
\par
(in no particular order of priorities)\tab\par
\tab .NET\par
\tab Debug symbols\par
\tab TLS\par
\tab Update public header\par
\ul\b\fs28 FAQ:\par
\ulnone\b0\fs22\par
\pard\nowidctlpar\fi720\sl276\slmult1 No one\rquote s asked me anything, so I\rquote ll go over some basic usage:\par
\pard\nowidctlpar\sl276\slmult1\par
\strike Why is there no \cf2 PEel_public.h \cf0 file in the repository?\par
\tab It's being finished, and would be useless as I am constantly updating structures until version 1.0.\strike0\par
\par
Why is \cf2 PEel_public.h\cf0  or this documentation incorrect?\par
\tab It's a low priority until version 1.0. Count yourself as a beta tester. In the meantime, including \cf2 PEel.h\cf0  should work.\par
\par
Error checking?\par
\tab Only on RAW_PE/VIRTUAL_MODULE structs passed to editing/deallocating functions. None is done on PE related fields, short of header signature checks if the build option is enabled. You should set your own SEH handlers up in case your PE is invalid and does happen to have a null pointer in a referenced field. \par
\par
Speaking of error checking, why so many errors?\par
\tab I can count the number of tests I\rquote ve done on my fingers. If you\rquote d like to fix this problem, feel free to send a push to github or send me a message.\par
\par
x64 support?\par
\tab It's coming, will be done by version 1.0. Why would you even use a x64 executable anyways, it's not like you're doing 128 bit math or hooking kernel processes.\par
\par
MrGetRvaPtr? Why is this scattered throughout the code, and why are you only checking the returns on half the calls?\par
\tab To allow you to use either a file, image, or custom aligned portion in any function requiring a RAW_PE. Any pointers that are filled into the RAW_PE struct but not referenced internally are not checked, seeing as an invalid field would then exit the function.\par
\par
        __________________________________________________________________________\par
\par
\ul\b\fs28 Glossary:\par
\ulnone\b0\fs22\par
Codecave\tab - Empty area usually due to padding and alignment, typically filled with 0s\par
EAT\tab\tab - Export Address Table\par
IAT\tab\tab - Import Address Table\par
IDH\tab\tab - IMAGE_DOS_HEADER\par
IDS\tab\tab - IMAGE_DOS_STUB\par
INH\tab\tab - IMAGE_NT_HEADERS\par
ISH\tab\tab - IMAGE_SECTION_HEADER\par
Pa\tab\tab - physical address or file offset\par
Rva\tab\tab - virtual address relative to module base\par
Va\tab\tab - virtual address\par
\par
\ul\b\fs28 Structs:\par
\ulnone\b0\fs22\par
\b RAW_PE:\par
\b0 Wraps a PE file and provides pointers to common structures for easy access. Alignment does not matter on any function with a RAW_PE parameter. \par
\par
\cf3\f1\fs19 // However anything involving headers or gaps in padding outside of sections will \cf0\par
\cf3 // produce\lang1033  \lang9 errors if you have the data structures heap allocated or otherwise \cf0\par
\cf3 // randomly sprawled\lang1033  \lang9 about.\cf0\f0\fs22\par
\par
\cf1\f1\fs19\tab typedef\cf0  \cf1 struct\cf0  \{\par
\lang1033\tab\tab\lang9 DOS_HEADER\tab\lang1033   \lang9 *pIDH;\par
\tab        DOS_STUB\tab\lang1033   \lang9 *pIDS;\par
\tab        NT_HEADERS\tab\lang1033   \lang9 *pINH;\par
\tab        SECTION_HEADER **ppISH;\par
\tab        \cf1 void\cf0\tab\lang1033         \lang9 **ppSectionData;\par
\tab        CODECAVE_LIST\lang1033   \lang9  *pCaveData;\par
\tab        IMPORT_LIBRARY\lang1033  \lang9  *pIL\lang1033 ;\lang9\par
\tab        PE_FLAGS\lang1033          \lang9 dwFlags;\par
\tab\} RAW_PE;\par
\f0\fs22\par
\b VIRTUAL_MODULE:\par
\b0 Wraps a loaded image in a RAW_PE and provides a linked list of loaded modules. cName holds a module name that is usable as an identifier, and is used in HlpXxx functions that search the VIRTUAL_MODULE list, such as loading.\par
\par
\pard\cf1\lang1033\f1\fs19\tab typedef\cf0  \cf1 struct\cf0  \{\par
\pard\fi720\tab RAW_PE32\tab  PE;\par
\cf1\tab void\cf0\tab    \tab *Flink,\par
\pard\fi720\li1440\tab *Blink;\par
\pard\fi720\cf1\tab char\cf0\tab\tab  cName[8];\cf3\par
\cf1\tab void\cf0 *\tab\tab  pBaseAddr;\par
\pard\tab\} VIRTUAL_MODULE32;\par
\pard\nowidctlpar\sl276\slmult1\lang9\f0\fs22\par
\ul\b\fs28 Functions:\par
\par
\fs24 Loading a PE file:\fs28\par
\ulnone\b0\fs22\par
\b MrAttachFile:\par
\par
\lang1033\b0\f2\fs19\tab\lang9\f3 LOGICAL LIBCALL MrAttach\lang1033\f2 File\lang9\f3 (\par
\lang1033\f2\tab\tab\lang9\f3 IN \cf1 const\cf0  \cf1 void\cf0 * \cf1 const\cf0  pFileBase, \par
\lang1033\f2\tab\tab\lang9\f3 OUT RAW_PE* rpe\par
\lang1033\f2\tab\lang9\f3 );\f0\fs22\par
\par
Attaches to a file that is stored as an array in memory. pFileBase should point to the DOS_HEADER. Only the DOS_HEADER*, DOS_STUB*, NT_HEADERS*, SECTION_HEADERS*, PE_FLAGS, and section data pointers will be filled. Will also set PE_FLAGS::Attached to TRUE.\par
\par
\b MrAttachImage:\b0\par
\par
\lang1033\f2\fs19\tab\lang9\f3 LOGICAL LIBCALL MrAttachImage(\par
\lang1033\f2\tab\tab\lang9\f3 IN \cf1 const\cf0  \cf1 void\cf0 * \cf1 const\cf0  pModuleBase, \par
\lang1033\f2\tab\tab\lang9\f3 OUT VIRTUAL_MODULE* vm\par
\lang1033\f2\tab\lang9\f3 );\f0\fs22\par
\par
Attaches to a mapped image at pModuleBase. Only the DOS_HEADER*, DOS_STUB*, NT_HEADERS*, SECTION_HEADERS*, PE_FLAGS, and section data pointers will be filled. Will also set PE_FLAGS::Attached to TRUE.\par
\par
\b MrDetachFile:\par
\b0\par
\lang1033\f2\fs19\tab\lang9\f3 LOGICAL LIBCALL MrDetachFile(\par
\lang1033\f2\tab\tab\lang9\f3 INOUT RAW_PE* rpe\par
\lang1033\f2\tab\lang9\f3 )\lang1033\f2 ;\par
\par
\lang9\f0\fs22 Detaches \f3\fs19 rpe\f0\fs22  and frees memory allocated by MrAttachFile. This function will fail if PE_FLAGS::Attached is not set to TRUE.\par
\par
\b MrDetachImage:\b0\par
\par
\tab\f3\fs19 LOGICAL EXPORT LIBCALL MrDetachImage32(\par
\lang1033\f2\tab\tab\lang9\f3 INOUT VIRTUAL_MODULE32* vm\par
\lang1033\f2\tab\lang9\f3 )\lang1033\f2 ;\lang9\f0\fs22\par
\par
Detaches \f3\fs19 vm\lang1033\f2  \lang9\f0\fs22 and frees allocated memory, along with unlinking vm from the module list. This function will fail if PE_FLAGS::Attached is not set to TRUE.\f3\fs19\par
\f0\fs22\par
}
 